{"ast":null,"code":"import { getHeroebyId } from \"./bases/08-import-export\";\nconst getImagePromesa = () => {\n  const promesa = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const randomNumber = Math.floor(Math.random() * 100) + 1;\n      if (randomNumber % 2 === 0) {\n        resolve(`https://picsum.photos/id/${randomNumber}/500`);\n      } else {\n        reject(new Error(`No se encontró una imagen con el número ${randomNumber}`));\n      }\n    }, 2000);\n  });\n  return promesa;\n};\ngetImagePromesa().then(url => {\n  const img = document.createElement(\"img\");\n  console.log(url);\n  img.src = url;\n  document.body.append(img);\n}).catch(error => {\n  console.error(\"Error al cargar la imagen\", error);\n});\n\n// console.log(getImagePromesa());\n\n// Ahora Vamos a hacer el mismo Ejercicio pero usando async\n// Usando la palabra async, consigo que una función me devuelva una promesa\n\nconst getImageFunct = Id => {\n  const heroe = getHeroebyId(Id);\n  return heroe;\n};\nconsole.log(\"Heroe con Función Normal\", getImageFunct(3));\nconst getImageAsync = async Id => {\n  const heroe = getHeroebyId(Id);\n  return heroe;\n};\nconsole.log(\"Heroe con Función Async\");\ngetImageAsync(3).then(heroe => {\n  console.log(heroe);\n}).catch(error => {\n  console.error(\"Error al cargar la imagen\", error);\n});\n\n// await\n// Ahora Despues de ver como se puede conseguir que la respuesta de una Función sea una promesa\n// Vamos a ver que es esto del await\n\n// Con await, lo que vamos a conseguir es que podamos escribir código asincrono como si fuera código sincrono, con lo que simplificamos mucho la escritura del Código\n\nconst getImageAsyncAwait = async Id => {\n  const heroe = getHeroebyId(Id);\n  return heroe;\n};\ngetImageAsyncAwait(3);","map":{"version":3,"names":["getHeroebyId","getImagePromesa","promesa","Promise","resolve","reject","setTimeout","randomNumber","Math","floor","random","Error","then","url","img","document","createElement","console","log","src","body","append","catch","error","getImageFunct","Id","heroe","getImageAsync","getImageAsyncAwait"],"sources":["/Users/josemanuelcepedayanez/Documents/02_Programacion/01_Curso_Programacion/20240829_DevTalles_React_Hook_MERN/02_Intro_JavaScript/intro-javascript/src/index.js"],"sourcesContent":["import { getHeroebyId } from \"./bases/08-import-export\";\nconst getImagePromesa = () => {\n  const promesa = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const randomNumber = Math.floor(Math.random() * 100) + 1;\n      if (randomNumber % 2 === 0) {\n        resolve(`https://picsum.photos/id/${randomNumber}/500`);\n      } else {\n        reject(\n          new Error(`No se encontró una imagen con el número ${randomNumber}`)\n        );\n      }\n    }, 2000);\n  });\n  return promesa;\n};\n\ngetImagePromesa()\n  .then((url) => {\n    const img = document.createElement(\"img\");\n    console.log(url);\n    img.src = url;\n    document.body.append(img);\n  })\n  .catch((error) => {\n    console.error(\"Error al cargar la imagen\", error);\n  });\n\n// console.log(getImagePromesa());\n\n// Ahora Vamos a hacer el mismo Ejercicio pero usando async\n// Usando la palabra async, consigo que una función me devuelva una promesa\n\nconst getImageFunct = (Id) => {\n  const heroe = getHeroebyId(Id);\n  return heroe;\n};\n\nconsole.log(\"Heroe con Función Normal\", getImageFunct(3));\n\nconst getImageAsync = async (Id) => {\n  const heroe = getHeroebyId(Id);\n  return heroe;\n};\n\nconsole.log(\"Heroe con Función Async\");\ngetImageAsync(3)\n  .then((heroe) => {\n    console.log(heroe);\n  })\n  .catch((error) => {\n    console.error(\"Error al cargar la imagen\", error);\n  });\n\n// await\n// Ahora Despues de ver como se puede conseguir que la respuesta de una Función sea una promesa\n// Vamos a ver que es esto del await\n\n// Con await, lo que vamos a conseguir es que podamos escribir código asincrono como si fuera código sincrono, con lo que simplificamos mucho la escritura del Código\n\nconst getImageAsyncAwait = async (Id) => {\n  const heroe = getHeroebyId(Id);\n  return heroe;\n};\n\ngetImageAsyncAwait(3);\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,0BAA0B;AACvD,MAAMC,eAAe,GAAGA,CAAA,KAAM;EAC5B,MAAMC,OAAO,GAAG,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IAC/CC,UAAU,CAAC,MAAM;MACf,MAAMC,YAAY,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC;MACxD,IAAIH,YAAY,GAAG,CAAC,KAAK,CAAC,EAAE;QAC1BH,OAAO,CAAC,4BAA4BG,YAAY,MAAM,CAAC;MACzD,CAAC,MAAM;QACLF,MAAM,CACJ,IAAIM,KAAK,CAAC,2CAA2CJ,YAAY,EAAE,CACrE,CAAC;MACH;IACF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC,CAAC;EACF,OAAOL,OAAO;AAChB,CAAC;AAEDD,eAAe,CAAC,CAAC,CACdW,IAAI,CAAEC,GAAG,IAAK;EACb,MAAMC,GAAG,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EACzCC,OAAO,CAACC,GAAG,CAACL,GAAG,CAAC;EAChBC,GAAG,CAACK,GAAG,GAAGN,GAAG;EACbE,QAAQ,CAACK,IAAI,CAACC,MAAM,CAACP,GAAG,CAAC;AAC3B,CAAC,CAAC,CACDQ,KAAK,CAAEC,KAAK,IAAK;EAChBN,OAAO,CAACM,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;AACnD,CAAC,CAAC;;AAEJ;;AAEA;AACA;;AAEA,MAAMC,aAAa,GAAIC,EAAE,IAAK;EAC5B,MAAMC,KAAK,GAAG1B,YAAY,CAACyB,EAAE,CAAC;EAC9B,OAAOC,KAAK;AACd,CAAC;AAEDT,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEM,aAAa,CAAC,CAAC,CAAC,CAAC;AAEzD,MAAMG,aAAa,GAAG,MAAOF,EAAE,IAAK;EAClC,MAAMC,KAAK,GAAG1B,YAAY,CAACyB,EAAE,CAAC;EAC9B,OAAOC,KAAK;AACd,CAAC;AAEDT,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;AACtCS,aAAa,CAAC,CAAC,CAAC,CACbf,IAAI,CAAEc,KAAK,IAAK;EACfT,OAAO,CAACC,GAAG,CAACQ,KAAK,CAAC;AACpB,CAAC,CAAC,CACDJ,KAAK,CAAEC,KAAK,IAAK;EAChBN,OAAO,CAACM,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;AACnD,CAAC,CAAC;;AAEJ;AACA;AACA;;AAEA;;AAEA,MAAMK,kBAAkB,GAAG,MAAOH,EAAE,IAAK;EACvC,MAAMC,KAAK,GAAG1B,YAAY,CAACyB,EAAE,CAAC;EAC9B,OAAOC,KAAK;AACd,CAAC;AAEDE,kBAAkB,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}